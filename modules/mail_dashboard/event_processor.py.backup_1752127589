# modules/mail_dashboard/event_processor.py
"""
Email Dashboard Event Processor - 새로운 이벤트 구조 처리
"""

import json
from datetime import datetime, timezone
from typing import Any, Dict, Optional

from infra.core import get_logger
from infra.core.exceptions import BusinessLogicError, ValidationError

from .repository import EmailDashboardRepository
from .schema import (
    ORGANIZATIONS,
    AgendaAll,
    AgendaChair,
    AgendaPending,
    EmailReceivedEvent,
)


class EmailDashboardEventProcessor:
    """이메일 대시보드 이벤트 처리기"""

    def __init__(self):
        self.repository = EmailDashboardRepository()
        self.logger = get_logger(__name__)

    def process_email_event(self, event_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        email.received 이벤트 처리

        Args:
            event_data: 이벤트 데이터

        Returns:
            처리 결과
        """
        try:
            # 1. 이벤트 검증 및 파싱
            event = self._validate_and_parse_event(event_data)

            # 2. agenda_all 테이블에 모든 이벤트 저장
            self._save_to_agenda_all(event)

            # 3. agenda_base_version이 없으면 pending 처리
            if not event.event_info.agenda_base_version:
                self._save_to_pending(
                    event, "no_agenda_base_version", "아젠다 기본 버전 없음"
                )
                return {
                    "success": True,
                    "action": "saved_to_pending",
                    "reason": "no_agenda_base_version",
                }

            # 4. 발신자 타입에 따른 처리
            if event.event_info.sender_type == "CHAIR":
                return self._process_chair_mail(event)
            elif event.event_info.sender_type == "MEMBER":
                return self._process_member_response(event)
            else:
                self._save_to_pending(
                    event,
                    "unknown_sender_type",
                    f"알 수 없는 발신자 타입: {event.event_info.sender_type}",
                )
                return {
                    "success": True,
                    "action": "saved_to_pending",
                    "reason": "unknown_sender_type",
                }

        except ValidationError as e:
            self.logger.error(f"이벤트 검증 실패: {str(e)}")
            self._save_raw_to_pending(event_data, "validation_error", str(e))
            return {"success": False, "error": "validation_error", "message": str(e)}
        except Exception as e:
            self.logger.error(f"이벤트 처리 중 오류: {str(e)}")
            self._save_raw_to_pending(event_data, "processing_error", str(e))
            return {"success": False, "error": "processing_error", "message": str(e)}

    def _validate_and_parse_event(
        self, event_data: Dict[str, Any]
    ) -> EmailReceivedEvent:
        """이벤트 데이터 검증 및 파싱"""
        try:
            # 기본값 설정으로 None 값 문제 해결
            event_info = event_data.get("event_info", {})

            # 필수 필드에 기본값 설정
            if not event_info.get("sent_time"):
                event_info["sent_time"] = datetime.now(timezone.utc).isoformat()

            if not event_info.get("decision_status"):
                event_info["decision_status"] = "created"

            if not event_info.get("sender_type"):
                event_info["sender_type"] = "UNKNOWN"

            if not event_info.get("body"):
                event_info["body"] = ""

            if not event_info.get("sender"):
                event_info["sender"] = "unknown@unknown.com"

            if not event_info.get("mail_type"):
                event_info["mail_type"] = "OTHER"

            if not event_info.get("parsing_method"):
                event_info["parsing_method"] = "unknown"

            if not event_info.get("keywords"):
                event_info["keywords"] = []

            # 수정된 데이터로 이벤트 생성
            event_data["event_info"] = event_info

            return EmailReceivedEvent(**event_data)
        except Exception as e:
            raise ValidationError(f"이벤트 데이터 형식 오류: {str(e)}")

    def _save_to_agenda_all(self, event: EmailReceivedEvent) -> None:
        """모든 이벤트를 agenda_all 테이블에 저장"""
        try:
            agenda_all = AgendaAll(
                event_id=event.event_id,
                agenda_code=event.event_info.agenda_code or "",
                sender_type=event.event_info.sender_type,
                sender_organization=event.event_info.sender_organization,
                sent_time=self._parse_datetime(event.event_info.sent_time),
                mail_type=event.event_info.mail_type,
                decision_status=event.event_info.decision_status,
                subject=event.event_info.subject,
                body=event.event_info.body,
                keywords=event.event_info.keywords,
                response_org=event.event_info.response_org,
                response_version=event.event_info.response_version,
                deadline=(
                    self._parse_datetime(event.event_info.deadline)
                    if event.event_info.deadline
                    else None
                ),
                has_deadline=event.event_info.has_deadline,
                sender=event.event_info.sender,
                sender_address=event.event_info.sender_address,
                agenda_panel=event.event_info.agenda_panel,
                agenda_year=event.event_info.agenda_year,
                agenda_number=event.event_info.agenda_number,
                agenda_base=event.event_info.agenda_base,
                agenda_version=event.event_info.agenda_version,
                agenda_base_version=event.event_info.agenda_base_version,
                parsing_method=event.event_info.parsing_method,
                hasAttachments=event.event_info.hasAttachments,
                sentDateTime=event.event_info.sentDateTime,
                webLink=event.event_info.webLink,
            )

            self.repository.save_agenda_all(agenda_all)
            self.logger.debug(f"agenda_all 저장 완료: event_id={event.event_id}")

        except Exception as e:
            self.logger.error(f"agenda_all 저장 실패: {str(e)}")

    def _process_chair_mail(self, event: EmailReceivedEvent) -> Dict[str, Any]:
        """의장 발송 메일 처리"""
        try:
            info = event.event_info

            # agenda_chair 저장
            agenda_chair = AgendaChair(
                agenda_base_version=info.agenda_base_version,
                agenda_code=info.agenda_code,
                sender_type=info.sender_type,
                sender_organization=info.sender_organization,
                sent_time=self._parse_datetime(info.sent_time),
                mail_type=info.mail_type,
                decision_status=info.decision_status,
                subject=info.subject,
                body=info.body,
                keywords=info.keywords,
                deadline=self._parse_datetime(info.deadline) if info.deadline else None,
                has_deadline=info.has_deadline,
                sender=info.sender,
                sender_address=info.sender_address,
                agenda_panel=info.agenda_panel,
                agenda_year=info.agenda_year,
                agenda_number=info.agenda_number,
                agenda_version=info.agenda_version,
                parsing_method=info.parsing_method,
                hasAttachments=info.hasAttachments,
            )

            success = self.repository.save_or_update_agenda_chair(agenda_chair)

            if success:
                self.logger.info(f"의장 메일 처리 완료: {info.agenda_base_version}")
                return {
                    "success": True,
                    "action": "chair_mail_processed",
                    "agenda_base_version": info.agenda_base_version,
                }
            else:
                raise BusinessLogicError("의장 메일 저장 실패")

        except Exception as e:
            self.logger.error(f"의장 메일 처리 실패: {str(e)}")
            return {
                "success": False,
                "error": "chair_mail_processing_error",
                "message": str(e),
            }

    def _process_member_response(self, event: EmailReceivedEvent) -> Dict[str, Any]:
        """멤버 응답 처리 (수정됨: response_org 우선 사용)"""
        try:
            info = event.event_info

            # 응답 조직 확인 - response_org를 우선 사용 (수정됨)
            response_org = None

            # 1순위: response_org 사용 (더 정확한 조직 코드)
            if info.response_org and info.response_org in ORGANIZATIONS:
                response_org = info.response_org
            # 2순위: response_org가 없거나 유효하지 않은 경우 sender_organization 사용
            elif info.sender_organization and info.sender_organization in ORGANIZATIONS:
                response_org = info.sender_organization

            if not response_org:
                self.logger.warning(
                    f"유효하지 않은 응답 조직: response_org={info.response_org}, "
                    f"sender_organization={info.sender_organization}"
                )
                self._save_to_pending(
                    event,
                    "invalid_organization",
                    f"유효하지 않은 조직: response_org={info.response_org}, sender_organization={info.sender_organization}",
                )
                return {
                    "success": True,
                    "action": "saved_to_pending",
                    "reason": "invalid_organization",
                }

            # 응답 내용과 시간 업데이트
            response_time = self._parse_datetime(info.sent_time)
            success = self.repository.update_member_response(
                agenda_base_version=info.agenda_base_version,
                organization=response_org,
                response_content=info.body,
                response_time=response_time,
            )

            if success:
                self.logger.info(
                    f"멤버 응답 처리 완료: {info.agenda_base_version} - {response_org} "
                    f"(response_org: {info.response_org}, sender_organization: {info.sender_organization})"
                )
                return {
                    "success": True,
                    "action": "member_response_processed",
                    "agenda_base_version": info.agenda_base_version,
                    "organization": response_org,
                }
            else:
                # 아젠다가 없는 경우 pending 처리
                self.logger.warning(f"해당 아젠다 없음: {info.agenda_base_version}")
                self._save_to_pending(
                    event,
                    "agenda_not_found",
                    f"아젠다를 찾을 수 없음: {info.agenda_base_version}",
                )
                return {
                    "success": True,
                    "action": "saved_to_pending",
                    "reason": "agenda_not_found",
                }

        except Exception as e:
            self.logger.error(f"멤버 응답 처리 실패: {str(e)}")
            return {
                "success": False,
                "error": "member_response_processing_error",
                "message": str(e),
            }

    def _save_to_pending(
        self, event: EmailReceivedEvent, reason: str, description: str
    ) -> None:
        """pending 테이블에 저장"""
        try:
            pending = AgendaPending(
                event_id=event.event_id,
                raw_event_data=json.dumps(event.model_dump(), ensure_ascii=False),
                error_reason=reason,
                sender_type=event.event_info.sender_type,
                sender_organization=event.event_info.sender_organization,
                sent_time=self._parse_datetime(event.event_info.sent_time),
                subject=event.event_info.subject,
            )

            self.repository.save_agenda_pending(pending)
            self.logger.info(
                f"Pending 저장: event_id={event.event_id}, reason={reason}"
            )

        except Exception as e:
            self.logger.error(f"Pending 저장 실패: {str(e)}")

    def _save_raw_to_pending(
        self, event_data: Dict[str, Any], reason: str, description: str
    ) -> None:
        """원본 데이터를 pending 테이블에 저장"""
        try:
            pending = AgendaPending(
                event_id=event_data.get("event_id"),
                raw_event_data=json.dumps(event_data, ensure_ascii=False),
                error_reason=reason,
                subject=description[:200],  # 에러 설명을 subject에 저장
            )

            self.repository.save_agenda_pending(pending)

        except Exception as e:
            self.logger.error(f"Raw pending 저장 실패: {str(e)}")

    def _parse_datetime(self, dt_str: Optional[str]) -> Optional[datetime]:
        """날짜/시간 문자열 파싱"""
        if not dt_str:
            return None

        try:
            # "2025-06-24 15:10:24 UTC" 형식 처리
            if " UTC" in dt_str:
                dt_str = dt_str.replace(" UTC", "+00:00")

            # ISO 형식으로 변환
            dt_str = dt_str.replace(" ", "T")

            dt = datetime.fromisoformat(dt_str)
            if dt.tzinfo is None:
                dt = dt.replace(tzinfo=timezone.utc)

            return dt

        except Exception as e:
            self.logger.warning(f"날짜 파싱 실패: {dt_str}, error={str(e)}")
            return None
